name: üöÄ Deploy Job Portal to DigitalOcean

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}-backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}-frontend

jobs:
  # Build and Push Docker Images
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4

    - name: üîê Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: üì¶ Extract metadata (tags, labels) for Backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: üì¶ Extract metadata (tags, labels) for Frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: üèóÔ∏è Build and push Backend Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}

    - name: üèóÔ∏è Build and push Frontend Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile.prod
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}

  # Deploy to DigitalOcean
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4

    - name: üîë Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.DIGITALOCEAN_SSH_KEY }}

    - name: üìã Create environment file
      run: |
        cat > .env.prod << 'EOF'
        # Database Configuration
        MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
        REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
        
        # JWT Configuration
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        
        # Email Configuration
        MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
        MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
        
        # Domain Configuration
        DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
        
        # Docker Images (from GitHub Container Registry)
        BACKEND_IMAGE=ghcr.io/${{ github.repository }}-backend:latest
        FRONTEND_IMAGE=ghcr.io/${{ github.repository }}-frontend:latest
        
        # Application Configuration
        SERVER_PORT=8080
        UPLOAD_MAX_SIZE=10MB
        SPRING_PROFILES_ACTIVE=prod
        ENVIRONMENT=production
        
        # Database Connection
        DB_HOST=mysql
        DB_PORT=3306
        DB_NAME=jobportal
        DB_USERNAME=jobportal
        
        # Redis Configuration
        REDIS_HOST=redis
        REDIS_PORT=6379
        
        # SMTP Configuration
        MAIL_HOST=smtp.gmail.com
        MAIL_PORT=587
        MAIL_PROTOCOL=smtp
        MAIL_AUTH=true
        MAIL_STARTTLS_ENABLE=true
        MAIL_STARTTLS_REQUIRED=true
        MAIL_DEBUG=false
        EOF

    - name: üåê Update Nginx configuration with domain
      run: |
        # Replace hardcoded domain with actual domain from secrets
        sed -i "s/zplusejobs.com/${{ secrets.DOMAIN_NAME }}/g" nginx/nginx.prod.conf
        sed -i "s/www.zplusejobs.com/www.${{ secrets.DOMAIN_NAME }}/g" nginx/nginx.prod.conf

    - name: üì¶ Copy files to server
      run: |
        # Add server to known hosts
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        
        # Create deployment directory
        ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p /opt/jobportal/deployment"
        
        # Copy deployment files
        scp docker-compose.prod.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/jobportal/
        scp .env.prod ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/jobportal/
        scp -r nginx/ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/jobportal/
        scp -r DB_Scripts/ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/jobportal/
        scp -r scripts/ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/jobportal/

    - name: üê≥ Deploy with Docker Compose
      run: |
        ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
        cd /opt/jobportal
        
        # Check if .env.prod file exists and has content
        echo "üîç Checking environment file..."
        if [ -f .env.prod ]; then
          echo "‚úÖ .env.prod file exists"
          echo "üìä File size: $(wc -c < .env.prod) bytes"
          echo "üìã First few lines:"
          head -5 .env.prod
        else
          echo "‚ùå .env.prod file not found!"
          exit 1
        fi
        
        # Ensure Docker Compose can read the environment file
        export $(cat .env.prod | grep -v '^#' | xargs)
        
        # Login to GitHub Container Registry
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        # Pull latest images
        docker-compose -f docker-compose.prod.yml pull
        
        # Stop existing containers
        docker-compose -f docker-compose.prod.yml down --remove-orphans
        
        # Start new deployment with explicit env file
        docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d
        
        # Wait for services to start
        echo "‚è≥ Waiting for services to start..."
        sleep 30
        
        # Check container status
        echo "üìä Container status:"
        docker-compose -f docker-compose.prod.yml ps
        
        # Check logs if containers are failing
        echo "üìã Checking container logs..."
        docker-compose -f docker-compose.prod.yml logs --tail=10 mysql || true
        docker-compose -f docker-compose.prod.yml logs --tail=10 redis || true
        
        # Wait longer for health checks
        echo "‚è≥ Waiting for health checks..."
        sleep 60
        
        # Verify deployment
        docker-compose -f docker-compose.prod.yml ps
        
        # Test application health
        curl -f http://localhost/health || echo "‚ö†Ô∏è Health check endpoint not yet available"
        curl -f http://localhost:8080/actuator/health || echo "‚ö†Ô∏è Backend health check not yet available"
        EOF

    - name: üîê Setup SSL Certificate
      run: |
        ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
        # Install SSL certificate for domain
        sudo certbot --nginx -d ${{ secrets.DOMAIN_NAME }} -d www.${{ secrets.DOMAIN_NAME }} --non-interactive --agree-tos --email ${{ secrets.MAIL_USERNAME }}
        EOF

    - name: üßπ Cleanup old images
      run: |
        ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
        # Remove old Docker images to save space
        docker image prune -f
        docker container prune -f
        EOF

    - name: üìä Deployment Summary
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "üì± Application: https://${{ secrets.DOMAIN_NAME }}"
        echo "üîç API Health: https://${{ secrets.DOMAIN_NAME }}/api/actuator/health"
        echo "üìß Deployed by: ${{ github.actor }}"
        echo "üè∑Ô∏è Commit: ${{ github.sha }}"
        echo "üïê Time: $(date)"